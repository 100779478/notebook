## HTTP 缓存机制：强缓存与协商缓存

### 强缓存

强缓存是一种直接从浏览器缓存中读取资源的机制，无需向服务器发送请求。它通过以下 HTTP 头部字段来控制：

* **Expires:** 指定资源的过期时间。HTTP/1.0 广泛使用，但由于时区差异等原因，不够精确。
* **Cache-Control:** HTTP/1.1 引入的更精确的缓存控制机制，主要取值有：
  * **public:** 任何缓存都可以缓存该资源。
  * **private:** 只有浏览器可以缓存该资源。
  * **no-cache:** 需要经过协商缓存验证后才能使用缓存。
  * **no-store:** 不缓存该资源。
  * **max-age=seconds:** 缓存资源的最大有效期，单位为秒。

### 缓存位置

* **内存缓存 (from memory cache):**
  * 存储在浏览器内存中，读取速度快，但进程关闭后数据丢失。
  * 常用于存储 JavaScript 和其他需要频繁访问的资源。
* **硬盘缓存 (from disk cache):**
  * 存储在硬盘中，读取速度较慢，但数据持久性更强。
  * 常用于存储 CSS 等静态资源。

### 协商缓存

协商缓存是在强缓存失效或不存在的情况下，浏览器向服务器发送请求，由服务器决定是否返回新的资源或使用缓存。它主要通过以下 HTTP 头部字段来实现：

* **Last-Modified:** 服务器返回的资源最后修改时间。浏览器在再次请求时，将该值放在 `If-Modified-Since` 请求头中，服务器比较两个时间戳，如果资源未修改，则返回 304 Not Modified。
* **ETag:** 服务器生成的一个唯一标识，代表资源的版本。浏览器在再次请求时，将该值放在 `If-None-Match` 请求头中，服务器比较两个 ETag，如果一致，则返回 304 Not Modified。

**ETag 和 Last-Modified 的优先级**

* **ETag** 比 `Last-Modified` 更精确，因为 ETag 可以唯一标识一个资源，而 `Last-Modified` 可能存在精度问题。
* 如果同时存在，则优先使用 ETag。

### 缓存流程总结

1. **浏览器** 首先检查强缓存是否命中。如果命中，直接使用缓存。
2. 如果强缓存未命中，则进行协商缓存：
   * 发送请求，携带 `If-Modified-Since` 或 `If-None-Match` 请求头。
   * 服务器根据请求头中的信息，决定是否返回 304（未修改）或 200（已修改）。
3. 如果协商缓存有效，浏览器使用缓存；否则，使用服务器返回的新资源，并更新本地缓存。
